from import_recs import *
import logging
import platform
import warnings
from typing import Any, List, Optional, Type, Union

from langchain_core.callbacks import (
    CallbackManagerForToolRun,
)
from langchain_core.pydantic_v1 import BaseModel, Field, root_validator
from langchain_core.tools import BaseTool

logger = logging.getLogger(__name__)

class BingSearchInput(BaseModel):
    query: str = Field()
    # numResults: int = Field(default=10, description="Number of search results to return")

class BingSearch(BaseTool):
    name = "BingSearch"
    description = "useful for when you need to search the web"
    args_schema: type[BaseModel] = BingSearchInput

    def _run(
        self, query: str, numResults: int = 10, run_manager: None = None
    ) -> str:
        """Use the tool."""

        search = BingSearchAPIWrapper()

        results = search.results(query=query, num_results=numResults)

        return results


    async def _arun(
        self, query: str, numResults: int = 10, run_manager: None = None
    ) -> str:
        """Use the tool asynchronously."""

        #call the sync version of this tool
        return self._run(query, numResults, run_manager)

class DALLE3Input(BaseModel):
    query: str = Field()

class DALLE3(BaseTool):
    name = "DALLE3"
    description = "useful for when you need to generate images"
    args_schema: type[BaseModel] = DALLE3Input

    def _run(
        self, query: str, run_manager: None
    ) -> str:
        """Use the tool."""
        
        result = client.images.generate(
            model="dall-e-3", # the name of your DALL-E 3 deployment
            prompt=query,
            n=1
        )

        image_url = json.loads(result.model_dump_json())

        return image_url


    async def _arun(
        self, query: str, run_manager: None
    ) -> str:
        """Use the tool asynchronously."""

        #call the sync version of this tool
        return self._run(query, run_manager)



class ShellInput(BaseModel):
    """Commands for the Bash Shell tool."""

    commands: Union[str, List[str]] = Field(
        ...,
        description="List of shell commands to run. Deserialized using json.loads",
    )
    """List of shell commands to run."""

    @root_validator
    def _validate_commands(cls, values: dict) -> dict:
        """Validate commands."""
        # TODO: Add real validators
        commands = values.get("commands")
        if not isinstance(commands, list):
            values["commands"] = [commands]
        # Warn that the bash tool is not safe
        # warnings.warn(
        #     "The shell tool has no safeguards by default. Use at your own risk."
        # )
        return values

# from langchain.utilities.bash import BashProcess
from langchain_experimental.llm_bash.bash import BashProcess

bash = BashProcess(
    strip_newlines = False,
    return_err_output = True,
    persistent = True
)

import getpass
import os
import platform

username = getpass.getuser()
# current_working_directory = os.getcwd()
operating_system = platform.system()
info = ""
info += f"[User Info]\nName: {username}\nCWD: {root_directory_for_sandbox}\nOS: {operating_system}"

#the first time you run this, you will need to cd into the directory where the experiments folder is located
bash.run(f"cd {root_directory_for_sandbox}")

def _get_default_bash_process() -> Any:
    """Get default bash process."""
    try:
        from langchain_experimental.llm_bash.bash import BashProcess
    except ImportError:
        raise ImportError(
            "BashProcess has been moved to langchain experimental."
            "To use this tool, install langchain-experimental "
            "with `pip install langchain-experimental`."
        )
    return bash


def _get_platform() -> str:
    """Get platform."""
    system = platform.system()
    if system == "Darwin":
        return "MacOS"
    return system


class ShellTool(BaseTool):
    """Tool to run shell commands."""

    process: Any = Field(default_factory=_get_default_bash_process)
    """Bash process to run commands."""

    name: str = "terminal"
    """Name of tool."""

    description: str = f"Run shell commands on this {_get_platform()} machine. useful for ls, cat + 100s of CLI commands."
    """Description of tool."""

    args_schema: Type[BaseModel] = ShellInput
    """Schema for input arguments."""

    ask_human_input: bool = False
    """
    If True, prompts the user for confirmation (y/n) before executing
    a command generated by the language model in the bash shell.
    """

    def _run(
        self,
        commands: Union[str, List[str]],
        run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> str:
        """Run commands and return final output."""

        print(f"Executing command:\n {commands}")  # noqa: T201

        if "vi " in commands or "vim " in commands or "nano " in commands:
            return "Error: vim is not supported in this environment. To edit files, please read out the entire file and then VERY CAREFULLY overwrite the file with the new content in the very specific position you want it."

        if "python3 " in commands or "python " in commands:
            return "Error: Python is not directly supported in this environment. Use the PythonFile(pythonFile) tool to run python code."


        try:
            if self.ask_human_input:
                user_input = input("Proceed with command execution? (y/n): ").lower()
                if user_input == "y":
                    return self.process.run(commands)
                else:
                    logger.info("Invalid input. User aborted command execution.")
                    return None  # type: ignore[return-value]
            else:
                return self.process.run(commands)

        except Exception as e:
            logger.error(f"Error during command execution: {e}")
            return None  # type: ignore[return-value]


#create a tool to run python files
class PythonFileInput(BaseModel):
    """Commands for the Bash Shell tool."""

    file: str = Field(
        ...,
        description="The name of the python file to run. Deserialized using json.loads",
    )

    @root_validator
    def _validate_file(cls, values: dict) -> dict:
        """Validate file."""

        file = values.get("file")
        if not isinstance(file, str):
            raise ValueError("The file name must be a string")
        return values

class PythonFile(BaseTool):
    """Tool to run python files."""
    process: Any = Field(default_factory=_get_default_bash_process)
    """Bash process to run commands."""


    name: str = "python"
    """Name of tool."""

    description: str = f"Run python files on this {_get_platform()} machine. useful for running python files."
    """Description of tool."""

    args_schema: Type[BaseModel] = PythonFileInput
    """Schema for input arguments."""

    ask_human_input: bool = False
    """
    If True, prompts the user for confirmation (y/n) before executing
    a command generated by the language model in the bash shell.
    """

    def _run(
        self,
        file: str,
        run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> str:
        """Run python file and return final output."""

        print(f"Executing python file:\n {file}")  # noqa: T201

        if "vi" in file or "vim" in file or "nano" in file:
            return "Error: vim is not supported in this environment. To edit files, please read out the entire file and then VERY CAREFULLY overwrite the file with the new content in the very specific position you want it."

        if "python3 " in file or "python " in file:
            return "Error: Python is not directly supported in this environment. To run Python code, you must run python3 <filename>.py"


        try:
            return self.process.run("python3 " + file)

        except Exception as e:
            logger.error(f"Error during file execution: {e}")
            return None  # type: ignore[return-value]


#write code to replace text in a file
class ReplaceTextInFileInput(BaseModel):
    data: str = Field(
        ...,
        description="A string containing file name, old text, and new text separated by the |!| delimiter.",
    )

    @root_validator
    def _validate_data(cls, values: dict) -> dict:
        """Validate data."""
        data = values.get("data")
        if not isinstance(data, str):
            raise ValueError("The data must be a string")
        return values

    def get_file(self) -> str:
        """Get the file name from the data."""
        return self.data.split('|!|')[0]

    def get_old_text(self) -> str:
        """Get the old text from the data."""
        return self.data.split('|!|')[1]

    def get_new_text(self) -> str:
        """Get the new text from the data."""
        return self.data.split('|!|')[2]


#maybe use sed 's/dogs/cats/g' example.txt > temp_file && mv temp_file example.txt

class ReplaceTextInFile(BaseTool):
    process: Any = Field(default_factory=_get_default_bash_process)
    name: str = "replace_text"
    description: str = f"Replace text in a file on this {_get_platform()} machine. useful for replacing text in files. Format: file_name|!|raw_entire_old_text|!|raw_entire_new_text"
    args_schema: Type[BaseModel] = ReplaceTextInFileInput
    ask_human_input: bool = False

    def _run(
        self,
        data: str,
        run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> str:
        """Run python file and return final output."""
        try:
            file, old_text, new_text = data.split('|!|')

            print(f"Replacing text in file:\n {file}")

            if "vi" in file or "vim" in file or "nano" in file:
                return "Error: vim is not supported in this environment. To edit files, please read out the entire file and then VERY CAREFULLY overwrite the file with the new content in the very specific position you want it."

            if "python3 " in file or "python " in file:
                return "Error: Python is not directly supported in this environment. To run Python code, you must run python3 <filename>.py"

            return self.process.run(f"sed 's/{old_text}/{new_text}/g' {file} > temp_file && mv temp_file {file}")

        except Exception as e:
            logger.error(f"Error during file execution: {e}")
            return e
